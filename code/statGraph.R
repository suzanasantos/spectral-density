################################################################################
## statGraph code for parameter estimation and model selection.
## Part of the code was obtained from 
## https://cran.r-project.org/web/packages/statGraph/
## and adapted to include the l1 distance and the cumulative distribution
## function of the eigenvalues.
################################################################################


#' Graph Information Criterion (GIC)
#'
#' 'GIC' returns the Kullback-Leibler divergence between an undirected graph and 
#' a given graph model. 
#'
#' @param A the adjacency matrix of the graph. For an unweighted graph it 
#' contains only 0s and 1s. For a weighted graph, it may contain nonnegative 
#' real values that correspond to the weights of the edges.
#'
#' @param model either a list, a string, a function or a matrix describing a 
#' graph model: 
#' 
#' A list that represents the spectral density of a model. It contains the 
#' components "x" and "y", which are numeric vectors of the same size. The "x" 
#' component contains the points at which the density was computed and the "y" 
#' component contains the observed density.
#'
#' A string that indicates one of the following models: "ER" (Erdos-Renyi random 
#' graph), "GRG" (geometric random graph), "KR" (k regular random graph), "WS" 
#' (Watts-Strogatz model), and "BA" (Barabási-Albert model). When the argument 
#' 'model' is a string, the user must also provide the model parameter by using 
#' the argument 'p'.  
#'
#' A function that returns a graph (represented by its adjacency matrix) 
#' generated by a graph model. It must contain two arguments: the first one
#' correponds to the graph size and the second to the parameter of the model. 
#' The model parameter will be provided by the argument 'p' of the 'GIC' 
#' function.
#'
#' A matrix containing the spectrum of the model. Each column contains the 
#' eigenvalues of a graph generated by the model. To estimate the spectral 
#' density of the model, the method will estimate the density of the values of 
#' each column, and then will take the average density.
#'
#' @param p the model parameter. The user must provide a valid parameter if the
#' argument 'model' is a string or a function. 
#' For the predefined models ("ER", "GRG", "KR", "WS", and "BA"), the parameter 
# 'p' corresponds to:
#
#' the probability to connect a pair of vertices, for the "ER" model 
#' (Erdos-Renyi random graph);
#' 
#' the radius used to contruct the geometric graph in a unit square, for the 
#' "GRG" model (geometric random graph);
#'
#' the degree 'k' of a regular graph, for the "KR" model (k regular random 
#' graph);
#' 
#' the probability to reconnect a vertex, for the "WS" model (Watts-Strogatz 
#' model);
#'
#' and the scaling exponent, for the "BA" model (Barabási-Albert model).
#'
#' @param bandwidth string indicating which criterion will be used to choose 
#' the bandwidth for the spectral density estimation. The available criteria are 
#' "Silverman" (default) and "Sturges".
#'
#' @param eigenvalues optional parameter. It contains the eigenvalues of matrix
#' A. Then, it can be used when the eigenvalues of A were previously computed. 
#' If no value is passed, then the eigenvalues of A will be computed by 'GIC'.
#'
#' @param dist distance between spectral densities (KL or L1)
#'
#' @return A real number corresponding to the Kullback-Leibler divergence 
#' between the observed graph and the graph model.
#'
#' @keywords graph_information_criterion
#'
#' @references
#' Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012) 
#' Discriminating Different Classes of Biological Networks by Analyzing the 
#' Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949. 
#' doi:10.1371/journal.pone.0049949.
#'
#' Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
#'
#' Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._, 
#' *21*, 65-66.
#' 
#' @examples
#' require(igraph)
#' A <- as.matrix(get.adjacency(erdos.renyi.game(100, p=0.5)))
#' # Using a string to indicate the graph model
#' result1 <- GIC(A, "ER", 0.5)
#' result1
#'
#' # Using a function to describe the graph model
#' # Erdos-Renyi graph
#' model <- function(n, p) {
#'    return(as.matrix(get.adjacency(erdos.renyi.game(n, p))))
#' }
#' result2 <- GIC(A, model, 0.5)
#' result2
#' @export
GIC <- function(A, model, p=NULL, bandwidth="Silverman", eigenvalues=NULL, dist="KL") {
    if (is.null(eigenvalues))
        eigenvalues <- (as.numeric(eigen(A, only.values = TRUE, 
                                         symmetric=TRUE)$values)/sqrt(nrow(A)))
    if (class(model) == "list") {
        f2 <- model
        f1 <- gaussianDensity(eigenvalues, from=min(f2$x), to=max(f2$x), 
                              bandwidth=bandwidth, npoints=1024)
    }
    else if (class(model) == "matrix") {
        f2 <- nDensities(model, from=min(eigenvalues), 
                                to=max(eigenvalues), bandwidth=bandwidth,
                                npoints=1024)
        if (sum(is.na(f2)) > 0)
            return(Inf)
        f2 <- list("x"=f2$x, "y"=rowMeans(f2$densities))
        f1 <- gaussianDensity(eigenvalues, from=min(f2$x), to=max(f2$x), 
                              bandwidth=bandwidth, npoints=1024)
    }
    else {
        fun <- model
        if (class(model) == "character") {
            if (model == "WS")
                fun <- WSfun(as.integer(sum(A)/(2*ncol(A))))
            else fun <- matchFunction(model)
        }
        f2 <- modelSpectralDensity(fun, ncol(A), p, from=min(eigenvalues), 
                                   to=max(eigenvalues), bandwidth=bandwidth,
                                   npoints=1024)
        if (sum(is.na(f2)) > 0)
            return(Inf)
        f1 <- gaussianDensity(eigenvalues, from=min(f2$x), to=max(f2$x), 
                              bandwidth=bandwidth, npoints=1024)
    }
    if (sum(is.na(f1)) > 0)
        return(Inf)
    if (sum(is.na(f2)) > 0)
        return(Inf)
    if (dist == "KL")
        return(KL(f1, f2))
    else if (dist == "L1")
        return(L1(f1, f2))

}

# Graph Information Criterion (GIC) based on the cumulative distribution of the 
# eigenvalues, 
GIC.cdf <- function(A, model, p=NULL, bandwidth="Silverman", eigenvalues=NULL, dist="L1") {
    if (is.null(eigenvalues))
        eigenvalues <- normSpectrum(A)
    if (class(model) == "list") {
        f2 <- model
        f1 <- gaussianDensity(eigenvalues, from=min(f2$x), to=max(f2$x), 
                              bandwidth=bandwidth, npoints=1024)
    }
    else if (class(model) == "matrix") {
        f2 <- modelCdfSpectra(model, from=min(eigenvalues), to=max(eigenvalues))
        if (sum(is.na(f2)) > 0)
            return(Inf)
        #f2 <- list("x"=f2$x, "y"=rowMeans(f2$densities))
        f1 <- ecdf(eigenvalues, from=min(f2$x), to=max(f2$x))
    }
    else {
        fun <- model
        if (class(model) == "character") {
            if (model == "WS")
                fun <- WSfun(as.integer(sum(A)/(2*ncol(A))))
            else fun <- matchFunction(model)
        }
        f2 <- modelSpectralDensity(fun, ncol(A), p, from=min(eigenvalues), 
                                   to=max(eigenvalues), bandwidth=bandwidth,
                                   npoints=1024)
        if (sum(is.na(f2)) > 0)
            return(Inf)
        f1 <- gaussianDensity(eigenvalues, from=min(f2$x), to=max(f2$x), 
                              bandwidth=bandwidth, npoints=1024)
    }
    if (sum(is.na(f1)) > 0)
        return(Inf)
    if (sum(is.na(f2)) > 0)
        return(Inf)
    return(matchFunction(dist)(f1, f2))
}

#' Graph parameter estimator
#'
#' 'graph.param.estimator' estimates the parameter that best approximates the 
#' model to the observed graph according to the Graph Information Criterion 
#' (GIC).
#'
#' @param A the adjacency matrix of the graph. For an unweighted graph it 
#' contains only 0s and 1s. For a weighted graph, it may contain nonnegative 
#' real values that correspond to the weights of the edges.
#'
#' @param model either a string, a function or an array describing a graph 
#' model: 
#'
#' A string that indicates one of the following models: "ER" (Erdos-Renyi random 
#' graph), "GRG" (geometric random graph), "KR" (k regular random graph), "WS" 
#' (Watts-Strogatz model), and "BA" (Barabási-Albert model). 
#'
#' A function that returns a graph (represented by its adjacency matrix) 
#' generated by a graph model. It must contain two arguments: the first one
#' correponds to the graph size and the second to the parameter of the model.
#'
#' A three-dimensional array containing the spectrum of the model. For each 
#' parameter p that will be considered, the array contains the eigenvalues of N 
#' graphs that were generated by the model with parameter p. The position 
#' (i,j,k) contains the j-th eigenvalue of the k-th graph that were generated 
#' with the i-th parameter. The attribute 'rownames' of the array corresponds to 
#' the values of the parameters converted to string. To obtain the spectral 
#' density for each parameter p, the method will estimate the density of the 
#' eigenvalues of each graph that were generated with parameter p, and then will 
#' take the average density. 
#'
#' @param parameters numeric vector containing the values that that will be 
#' considerated for the parameter estimation. The 'graph.param.estimator' will
#' return the element of 'parameter' that minimizes the Graph Information 
#' Criterion (GIC). 
#' If the user does not provide the argument 'parameters', and 'model' is an 
#' array, then the values considered for the parameter estimation are the 
#' rownames converted to a numeric vector. If 'model' is a string, then
#' default values are used for the predefined models ("ER", "GRG", "KR", "WS", 
#' and "BA"). The default 'parameter' argument corresponds to a sequence from 
#' 
#' 0 to 1 with step 'eps' for the "ER" model (Erdos-Renyi random graph), in 
#' which the parameter corresponds to the probability to connect a pair of 
#' vertices;
#' 
#' 0 to sqrt(2) with step 'eps' for the "GRG" model (geometric random graph), in 
#' which the parameter corresponds to the radius used to contruct the geometric 
#' graph in a unit square;
#'
#' 0 to 'n' with step 'n*eps' for the "KR" model (k regular random graph), in 
#' which the parameter of the model corresponds to the degree 'k' of a regular 
#' graph;
#' 
#' 0 to 1 with step 'eps' for the "WS" model (Watts-Strogatz model), in which 
#' the parameter corresponds to the probability to reconnect a vertex;
#'
#' and 0 to 3 with step 'eps' for the "BA" model (Barabási-Albert model), in  
#' which the parameter corresponds to the scaling exponent.
#'
#' @param eps precision of the grid (default is 0.01).
#'
#' @param bandwidth string indicating which criterion will be used to choose the 
#' bandwidth for the spectral density estimation. The available criteria are 
#' "Silverman" (default) and "Sturges".
#'
#' @param eigenvalues optional parameter. It contains the eigenvalues of matrix
#' A. Then, it can be used when the eigenvalues of A were previously computed. 
#' If no value is passed, then the eigenvalues of A will be computed by 
#' 'graph.param.estimator'.
#'
#' @param dist distance between spectral densities (KL or L1)
#' 
#' @return A list containing:
#' \item{p}{the parameter estimate. For the "ER", "GRG", "KR", "WS", and "BA"
#' models, the parameter corresponds to the probability to connect a pair of 
#' vertices, the radius used to contruct the geometric graph in a unit square,
#' the degree k of a regular graph, the probability to reconnect a vertex, and 
#' the scaling exponent, respectively.}  
#' \item{KL}{the Graph Information Criterion (GIC), i. e. the Kullback-Leibler 
#' divergence between the observed graph and the graph model with the estimated
#' parameter.}
#'
#' @keywords parameter_estimation
#'
#' @references
#' Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012) 
#' Discriminating Different Classes of Biological Networks by Analyzing the 
#' Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949. 
#' doi:10.1371/journal.pone.0049949.
#' 
#' Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
#'
#' Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._, 
#' *21*, 65-66.
#' 
#' @examples
#' require(igraph)
#' A <- as.matrix(get.adjacency(erdos.renyi.game(50, p=0.5)))
#'
#' # Using a string to indicate the graph model
#' result1 <- graph.param.estimator(A, "ER", eps=0.25)
#' result1
#'
#' # Using a function to describe the graph model
#' # Erdos-Renyi graph
#' model <- function(n, p) {
#'    return(as.matrix(get.adjacency(erdos.renyi.game(n, p))))
#' }
#' result2 <- graph.param.estimator(A, model,  seq(0.2, 0.8, 0.1))
#' result2
#'
#' @export
graph.param.estimator <- function(A, model, parameters=NULL, eps=0.01, 
                                  bandwidth="Silverman", eigenvalues=NULL, dist="KL") {
    n <- ncol(A)
    if (class(model) == "function" && is.null(parameters)) {
        stop("It is necessary to enter the parameters that will be evaluated.")
    }
    if (class(model) == "array") {
        if (is.null(parameters))
            parameters <- as.numeric(rownames(model))
    }
    else if (is.null(parameters)) {
            parameters <- seq(0, 1, eps)
            if (model == "GRG")
                parameters <- seq(0, sqrt(2), eps)
            if (model == "BA")
                parameters <- seq(0, 3, eps)
            if (model == "KR")
                parameters <- as.integer(seq(0, 1, eps)*n)
    }
    if (is.null(eigenvalues))
        eigenvalues <- (as.numeric(eigen(A, only.values = TRUE)$values)/
                            sqrt(nrow(A)))
    pmin <- -1
    klmin <- Inf
    for (p in parameters) {
       if (class(model) == "array")
            kl <- GIC(A, model[as.character(p),,], p, bandwidth, 
                      eigenvalues=eigenvalues, dist=dist) 
       else 
            kl <- GIC(A, model, p, bandwidth, eigenvalues=eigenvalues, dist=dist) 
       if (kl < klmin) {
           klmin <- kl
           pmin <- p
       }
    }
    return(list("p"=pmin, "GIC"=klmin))
}

# Graph parameter estimator based on the cumulative distribution function (CDF)
graph.param.estimator.cdf <- function(A, model, parameters=NULL, eps=0.01, 
                                  bandwidth="Silverman", eigenvalues=NULL, dist="L1") {
    n <- ncol(A)
    if (class(model) == "function" && is.null(parameters)) {
        stop("It is necessary to enter the parameters that will be evaluated.")
    }
    if (class(model) == "array") {
        if (is.null(parameters))
            parameters <- rownames(model)
    }
    else if (is.null(parameters)) {
            parameters <- seq(0, 1, eps)
            if (model == "GRG")
                parameters <- seq(0, sqrt(2), eps)
            if (model == "BA")
                parameters <- seq(0, 3, eps)
            if (model == "KR")
                parameters <- as.integer(seq(0, 1, eps)*n)
    }
    if (is.null(eigenvalues))
        eigenvalues <- normSpectrum(A)
    pmin <- -1
    klmin <- Inf
    for (p in parameters) {
       if (class(model) == "array") {
            kl <- GIC.cdf(A, model[p,,], as.numeric(p), bandwidth, 
                      eigenvalues=eigenvalues, dist=dist) 
        }
       else 
            kl <- GIC.cdf(A, model, p, bandwidth, eigenvalues=eigenvalues, dist=dist) 
       if (kl < klmin) {
           klmin <- kl
           pmin <- p
       }
    }
    return(list("p"=pmin, "GIC"=klmin))
}


#' Graph model selection
#'
#' 'graph.model.selection' selects the graph model that best approximates the 
#' observed graph according to the Graph Information Criterion (GIC).
#'
#' @param A the adjacency matrix of the graph. For an unweighted graph it 
#' contains only 0s and 1s. For a weighted graph, it may contain nonnegative 
#' real values that correspond to the weights of the edges.
#'
#' @param models either a vector of strings, a list of functions or a list of 
#' arrays describing graph models: 
#' 
#' A vector of strings cotaining some of the following models: "ER" (Erdos-Renyi 
#' random graph), "GRG" (geometric random graph), "KR" (k regular random graph), 
#' "WS" (Watts-Strogatz model), and "BA" (Barabási-Albert model).
#'
#' A list of functions. Each function returns a graph (represented by its 
#' adjacency matrix) generated by a graph model and has two arguments: the graph 
#' size and the model parameter, in this order.
#' 
#' A list of arrays. Each elememt of the list is a three-dimensional array 
#' containing the spectrum of the corresponding model. Let M be a graph model.
#' For each parameter p considered for M, the array of model M contains the 
#' eigenvalues of N graphs that were generated by M with parameter p. The 
#' position (i,j,k) of the array contains the j-th eigenvalue of the k-th graph 
#' that were generated by M with the i-th parameter. The attribute 'rownames' of 
#' the array corresponds to the values of the parameter converted to string. To 
#' obtain the spectral density for each parameter p, the method will estimate 
#' the density of the eigenvalues of each graph that were generated by M with 
#' parameter p, and then will take the average density. 
#'
#' If the argument "models" is NULL, then the "ER", "WS", and "BA" models will 
#' be considered for the model selection.
#'
#' @param parameters list of numeric vectors. Each vector contains the values 
#' that will be considerated for the parameter estimation of the corresponding 
#' model. 
#' If the user does not provide the argument 'parameters', then default values 
#' are used for the predefined models ("ER", "GRG", "KR", "WS", and "BA"). 
#' The default vector corresponds to a sequence from 
#' 
#' 0 to 1 with step 'eps' for the "ER" model (Erdos-Renyi random graph), in 
#' which the parameter corresponds to the probability to connect a pair of 
#' vertices;
#' 
#' 0 to sqrt(2) with step 'eps' for the "GRG" model (geometric random graph), in 
#' which the parameter corresponds to the radius used to contruct the geometric 
#' graph in a unit square;
#'
#' 0 to 'n' with step 'n*eps' for the "KR" model (k regular random graph), in 
#' which the parameter of the model corresponds to the degree 'k' of a regular 
#' graph;
#' 
#' 0 to 1 with step 'eps' for the "WS" model (Watts-Strogatz model), in which 
#' the parameter corresponds to the probability to reconnect a vertex;
#'
#' and 0 to 3 with step 'eps' for the "BA" model (Barabási-Albert model), in  
#' which the parameter corresponds to the scaling exponent.
#'
#' @param eps precision of the grid (default is 0.01).
#'
#' @param bandwidth string indicating which criterion will be used to choose 
#' the bandwidth for the spectral density estimation. The available criteria are 
#' "Silverman" (default) and "Sturges".
#'
#' @param eigenvalues optional parameter. It contains the eigenvalues of matrix
#' A. Then, it can be used when the eigenvalues of A were previously computed. 
#' If no value is passed, then the eigenvalues of A will be computed by 
#' 'graph.model.selection'.
#'
#' @param dist distance between spectral densities (KL or L1)
#'
#' @return A list containing:
#' \item{model}{the indice(s) or name(s) of the selected model(s), i. e. the
#' model(s) that minimize(s) the Graph Information Criterion (GIC).}  
#' \item{estimates}{a matrix in which each row corresponds to a model, the 
#' column "p" corresponds to the parameter estimate, and the column "GIC" 
#' corresponds to the Graph Information Criterion (GIC), i. e. the 
#' Kullback-Leibler divergence between the observed graph and the model.}
#'
#' @keywords model_selection
#'
#' @references
#' Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012) 
#' Discriminating Different Classes of Biological Networks by Analyzing the 
#' Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949. 
#' doi:10.1371/journal.pone.0049949.
#' 
#' Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
#'
#' Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._, 
#' *21*, 65-66.
#' 
#' 
#' @examples
#' 
#' require(igraph)
#' A <- as.matrix(get.adjacency(erdos.renyi.game(30, p=0.5)))
#' # Using strings to indicate the graph models
#' result1 <- graph.model.selection(A, models=c("ER", "WS"), eps=0.5)
#' result1
#' # Using functions to describe the graph models
#' # Erdos-Renyi graph
#' model1 <- function(n, p) {
#'    return(as.matrix(get.adjacency(erdos.renyi.game(n, p))))
#' }
#' # Watts-Strougatz graph
#' model2 <- function(n, pr, K=8) {
#'     return(as.matrix(get.adjacency(watts.strogatz.game(1, n, K, pr))))
#' }
#' parameters <- list(seq(0, 1, 0.5), seq(0, 1, 0.5))
#' result2 <- graph.model.selection(A, list(model1, model2), parameters)
#' result2
#' @export
graph.model.selection <- function(A, models=NULL, parameters=NULL, eps=0.01,
                                  bandwidth="Silverman", eigenvalues=NULL, dist="KL") {
    n <- ncol(A)
    if (class(models) == "list") {
        if (class(models[[1]]) == "function") 
        stop("It is necessary to enter the parameters that will be evaluated.")
    }
    if (is.null(models)) {
        models <- c("ER", "WS", "BA")
    }
    results <- matrix(NA, length(models), 2)
    colnames(results) <- c("p", "GIC")
    if (class(models) == "character") {
        rownames(results) <- models
    }
    if (class(models) == "list") {
        if (!is.null(names(models)))
            rownames(results) <- names(models)
    }
    p <- NULL
    if (is.null(eigenvalues))
        eigenvalues <- (as.numeric(eigen(A, only.values=TRUE, 
                                         symmetric=TRUE)$values)/sqrt(nrow(A)))
    for (i in 1:length(models)) {
        if (!is.null(parameters))
            p <- parameters[[i]]
        r <- graph.param.estimator(A, models[[i]], p, eps, bandwidth, 
                                   eigenvalues=eigenvalues, dist=dist) 
        results[i, "p"] <- r$p
        results[i, "GIC"] <- r$GIC
    }
    m <- which(results[, "GIC"] == min(results[, "GIC"]))
    if (!is.null(rownames(results)))
        m <- rownames(results)[m]
    return(list("model"=m, "estimates"=results))
}

# Graph model selection based on the cumulative distribution function (CDF)
graph.model.selection.cdf <- function(A, models=NULL, parameters=NULL, eps=0.01,
                                  bandwidth="Silverman", eigenvalues=NULL, dist="L1") {
    n <- ncol(A)
    if (class(models) == "list") {
        if (class(models[[1]]) == "function") 
        stop("It is necessary to enter the parameters that will be evaluated.")
    }
    if (is.null(models)) {
        models <- c("ER", "WS", "BA")
    }
    results <- matrix(NA, length(models), 2)
    colnames(results) <- c("p", "GIC")
    if (class(models) == "character") {
        rownames(results) <- models
    }
    if (class(models) == "list") {
        if (!is.null(names(models)))
            rownames(results) <- names(models)
    }
    p <- NULL
    if (is.null(eigenvalues))
        eigenvalues <- (as.numeric(eigen(A, only.values=TRUE, 
                                         symmetric=TRUE)$values)/sqrt(nrow(A)))
    for (i in 1:length(models)) {
        if (!is.null(parameters))
            p <- parameters[[i]]
        r <- graph.param.estimator.cdf(A, models[[i]], p, eps, bandwidth, 
                                   eigenvalues=eigenvalues, dist=dist) 
        results[i, "p"] <- r$p
        results[i, "GIC"] <- r$GIC
    }
    m <- which(results[, "GIC"] == min(results[, "GIC"]))
    if (!is.null(rownames(results)))
        m <- rownames(results)[m]
    return(list("model"=m, "estimates"=results))
}


################################################################################
## Auxiliar functions
################################################################################

# Divergence between spectral densities ----------------------------------------

# Returns the Jensen-Shannon divergence between two densities
JS <- function(f1, f2) {
    fm <- f1
    fm$y <- (f1$y + f2$y)/2
    return((KL(f1, fm) + KL(f2, fm))/2)
}

# Returns the Kullback-Leibler divergence between two densities
KL <- function(f1, f2) {
    y <- f1$y
    n <- length(y)
    for (i in 1:n) {
        if (y[i] != 0 && f2$y[i] == 0)
            return(Inf)
        if (y[i] != 0)
            y[i] <- y[i]*log(y[i]/f2$y[i])
    }
    return(trapezoidSum(f1$x, y))
}

L1 <- function(f, g) {
    return(trapezoidSum(f$x, abs(f$y - g$y)))
}

# Returns the Hellinger's distance between two densities
hellinger <- function(f1, f2) {
    x <- f1$x
    y <- (sqrt(f1$y) - sqrt(f2$y))^2
    return(trapezoidSum(x, y)/2)
}

# Returns the Hellinger's distance between two densities
hellinger2 <- function(f1, f2) {
    x <- f1$x
    y <- (sqrt(f1$y) - sqrt(f2$y))^2
    return(trapezoidSum(x, y)/2)
}

tvnorm <- function(f1, f2) {
    x <- f1$x 
    return(sum(abs(f1$y - f2$y))/2)
}

# Integral computation ---------------------------------------------------------

# Given a partition x[1]...x[n] and y[i] = f(x[i]), returns the trapezoid sum
# approximation for int_{x[1]}^{x[n]}{f(x)dx}
trapezoidSum <- function (x, y) {
    n <- length(x)
    delta <- (x[2] - x[1])
    area <- sum(y[2:(n-1)])
    area <- (area + (y[1] + y[n])/2)*delta
    return(area)
}

# Cumulative estimation --------------------------------------------------------


# Given the graph adjancecy matrix, it returns the normalized spectrum
normSpectrum <- function(A) {
  s <- (as.numeric(eigen(A, only.values=TRUE, symmetric=TRUE)$values)/
          sqrt(nrow(A)))
  s <- s[-1]
  return(s)
}

# Given the set of eigenvalues, it returns the empirical cumulative function,
# in the interval [from, to] at npoints points.
ecdf <- function(eigenvalues, from=NULL, to=NULL, npoints=1024) {
    if (is.null(from))
        from <- min(eigenvalues)
    if (is.null(to))
        to <- max(eigenvalues)
    x <- seq(from, to, (to-from)/(npoints-1))
    y <- c()
    n <- length(eigenvalues)
    for (i in 1:length(x)) {
        y[i] <- sum(eigenvalues <= x[i])/n
    }
    return(list("x"=x, "y"=y))
}


# Monde Carlo approximation of the random graph model cumulative distribution 
# (CDF).
# Parameters:
# model - a function that receives the number of vertices n and a parameter p 
# and return an instance of a random grapb
# n - graph size (number of vertices)
# p - random graph model parameter
# ngraphs - number of Monte Carlo instances for approaximating the model CDF
# [from, to] - interval at which the CDF will be computed
# npoints - number of points at which the CDF will be computed
modelCdf <- function(model, n, p, ngraphs=50, from=NULL, to=NULL, npoints=1024) {
    A <- model(n, p)
    eig <- normSpectrum(A)
    spectra <- matrix(NA, length(eig), ngraphs)
    spectra[,1] <- eig
    for (i in 2:ngraphs) {
        A <- model(n, p)
        spectra[,i] <- normSpectrum(A)
    }
    cdfs <- matrix(NA, npoints, ngraphs)
    minimum <- min(spectra)
    maximum <- max(spectra)
    if (!is.null(from) && !is.null(to)) {
     
       minimum <- min(minimum, from)
        maximum <- max(maximum, to)
    }
    #if (!is.null(from))medição de
    #   minimum <- from
    #if (!is.null(to))
    #   maximum < to

    for (i in 1:ngraphs) {
        f <- ecdf(spectra[,i], minimum, maximum, npoints)
        cdfs[,i] <- f$y
        x <- f$x
    }
    return(list("f"=list("x" = x, "y" = rowMeans(cdfs)), "spectra"=spectra))
}


# Monde Carlo approximation of the random graph model cumulative distribution 
# (CDF) for a given set of pre-computed spectra.
modelCdfSpectra <- function(spectra, from=NULL, to=NULL, npoints=1024) {
    ngraphs <- ncol(spectra)
    cdfs <- matrix(NA, npoints, ngraphs)
    minimum <- min(spectra)
    maximum <- max(spectra)
    if (!is.null(from) && !is.null(to)) {
     
       minimum <- min(minimum, from)
        maximum <- max(maximum, to)
    }
    #if (!is.null(from))
    #   minimum <- from
    #if (!is.null(to))
    #   maximum < to

    for (i in 1:ngraphs) {
        f <- ecdf(spectra[,i], minimum, maximum, npoints)
        cdfs[,i] <- f$y
        x <- f$x
    }
    return(list("x" = x, "y" = rowMeans(cdfs)))
}



# Density estimation -----------------------------------------------------------

# Returns the kernel bandwidth for a given sample x
kernelBandwidth <- function(x) {
    n <- length(x)
    # Sturges' criterion
    nbins <- ceiling(log2(n) + 1)
    return(abs(max(x) - min(x))/nbins)
}


# Returns the density function for a given sample x at n points in the interval
# [form, to]
gaussianDensity <- function(x, from=NULL, to=NULL, bandwidth="Silverman", 
                            npoints=1024) {
    if (bandwidth == "Sturges")
        bw <- kernelBandwidth(x)
    else if (bandwidth == "Silverman")
        bw <- bw.nrd0(x)
    else if (bandwidth == "cross-validation")
        bw <- bw.ucv(x)
    if (bw == 0)
       return(NA)
    if (is.null(from) || is.null(to))
        f <- density(x, bw=bw, n=npoints)
        #f <- density(x, n=npoints)

    else
        f <- density(x, bw=bw, from=from, to=to, n=npoints)
        #f <- density(x, from=from, to=to, n=npoints)

    area <- trapezoidSum(f$x, f$y)
    return(list("x"=f$x, "y"=f$y/area))
}

# Returns the spectral density for a given adjacency matrix A
spectralDensity <- function(A, from=NULL, to=NULL, bandwidth="Silverman", 
                            npoints=1024) {
    eigenvalues <- (as.numeric(eigen(A, only.values=TRUE, 
                                     symmetric=TRUE)$values)/sqrt(nrow(A)))
    return(gaussianDensity(eigenvalues, from, to, bandwidth=bandwidth, 
                           npoints=npoints))
}



nDensities <- function (spectra, from=NULL, to=NULL, 
                                bandwidth="Silverman", npoints=1024) {
  ngraphs <- ncol(spectra)
  densities <- matrix(NA, npoints, ngraphs)
  minimum <- min(spectra)
  maximum <- max(spectra)
  if (!is.null(from) && !is.null(to)) {
    minimum <- min(minimum, from)
    maximum <- max(maximum, to)
  }
  for (i in 1:ngraphs) {
    f <- gaussianDensity(spectra[,i], bandwidth=bandwidth,
                         from=minimum, to=maximum,
                         npoints=npoints)
    if (sum(is.na(f)) > 0) {
        return(NA)
    }
    else {
        densities[,i] <- f$y
        x <- f$x
    }
  }
  return(list("x"=x, "densities"=densities))
}


# Returns the spectral densities for given adjacency matrices A1 and A2 at the
# same points
spectralDensities <- function(A1, A2, bandwidth="Silverman",
                              npoints=1024) {
    n1 <- nrow(A1)
    n2 <- nrow(A2)
    e1 <- (as.numeric(eigen(A1, only.values = TRUE, 
                            symmetric=TRUE)$values)/sqrt(n1))
    e2 <- (as.numeric(eigen(A2, only.values = TRUE, 
                            symmetric=TRUE)$values)/sqrt(n2))
    #b1 <- kernelBandwidth(e1)
    #b2 <- kernelBandwidth(e2)
    #from <- min(min(e1) - 3*b1, min(e2) - 3*b2)
    #to <- max(max(e1) + 3*b1, max(e2) + 3*b2)
    from <- min(e1, e2)
    to <- max(e1, e2)
    f1 <- gaussianDensity(e1, from=from, to=to, bandwidth=bandwidth, 
                          npoints=npoints)
    f2 <- gaussianDensity(e2, from=from, to=to, bandwidth=bandwidth, 
                          npoints=npoints)
    if (sum(is.na(f1)) > 0 || sum(is.na(f2)) > 0)
        return(NA)
    return(list("f1"=f1, "f2"=f2))
}

# Returns the spectral densities for a list of adjacency matrices at the
# same points
nSpectralDensities <- function (adjacencyMatrices, from=NULL, to=NULL, 
                                bandwidth="Silverman") {
    npoints <- 1024
    ngraphs <- length(adjacencyMatrices)
    ns <- unlist(lapply(adjacencyMatrices, ncol))
    #n <- ncol(adjacencyMatrices[[1]])
    spectra <- matrix(NA, max(ns), ngraphs)
    for (i in 1:ngraphs) {
        A <- adjacencyMatrices[[i]]
        n <- ncol(A)
        eigenvalues <- (as.numeric(eigen(A, only.values = TRUE, 
                                         symmetric=TRUE)$values)/sqrt(n))
        spectra[1:n,i] <- eigenvalues
    }
    densities <- matrix(NA, npoints, ngraphs)
    minimum <- min(spectra, na.rm=T)
    maximum <- max(spectra, na.rm=T)
    if (!is.null(from) && !is.null(to)) {
        minimum <- min(minimum, from)
        maximum <- max(maximum, to)
    }
    for (i in 1:ngraphs) {
        n <- ns[i]
        f <- gaussianDensity(spectra[1:n,i], bandwidth=bandwidth,
                             from=minimum, to=maximum,
                             npoints=npoints)

        densities[,i] <- f$y
        x <- f$x
    }
    return(list("x"=x, "densities"=densities))
}

# Estimates the spectral density of a graph model
modelSpectralDensity <- function(fun, n, p, ngraphs=50, from=NULL, to=NULL, 
                                 bandwidth="Silverman", npoints=1024) {
    
    if (class(model) == "matrix")
        spectra <- model
    else {
        spectra <- matrix(NA, n, ngraphs)
        for (i in 1:ngraphs) {
            A <- fun(n, p)
            eigenvalues <- (as.numeric(eigen(A, only.values = TRUE, 
                                             symmetric=TRUE)$values)/sqrt(nrow(A)))
            spectra[,i] <- eigenvalues
        }
    }
    densities <- matrix(NA, npoints, ngraphs)
    minimum <- min(spectra)
    maximum <- max(spectra)
    if (!is.null(from) && !is.null(to)) {
        minimum <- min(minimum, from)
        maximum <- max(maximum, to)
    }
    for (i in 1:ngraphs) {
        f <- gaussianDensity(spectra[,i], from=minimum, to=maximum, 
                             bandwidth=bandwidth, npoints=npoints)

        densities[,i] <- f$y
        x <- f$x
    }
    return(list("x" = x, "y" = rowMeans(densities)))
}

modelSpectra <- function(model, n, p, ngraphs=50) {
    fun <- model
    if (is.character(model)) {
        if (model == "WS")
            fun <- WSfun(2)
        else fun <- matchFunction(model)
    }
    spectra <- matrix(NA, n, ngraphs)
    for (i in 1:ngraphs) {
        A <- fun(n, p)
        eigenvalues <- normSpectrum(A)
        spectra[,i] <- eigenvalues
    }
   return(spectra)
}

modelSpectra <- function(model, n, p, ngraphs=50) {
    fun <- model
    if (is.character(model)) {
        if (model == "WS")
            fun <- WSfun(2)
        else fun <- matchFunction(model)
    }
    A <- fun(n, p)
    eigenvalues <- normSpectrum(A)
    spectra <- matrix(NA, length(eigenvalues), ngraphs)
    spectra[,1] <- eigenvalues
    for (i in 2:ngraphs) {
        A <- fun(n, p)
        eigenvalues <- normSpectrum(A)
        spectra[,i] <- eigenvalues
    }
   return(spectra)
}

matchFunction <- function(name) {
    return(match.fun(name))
}

# Watts-Strougatz graph
WSfun <- function(K){
    f <- function(n, pr) {
        WS(n, pr, K=K)
    }
    return(f)
}

# Graph models  ----------------------------------------------------------------

# Erdos-Renyi graph 
ER <- function(n, p) {
    return(as.matrix(igraph::get.adjacency(igraph::erdos.renyi.game(n, p, 
                                                                   type="gnp",
                                                            directed = FALSE))))
}

# Geometric graph
GRG <- function(n, r) {
    return(as.matrix(igraph::get.adjacency(igraph::grg.game(n, r))))
}

# Barabasi-Albert graph
BA <- function(n, ps) {
    return(as.matrix(igraph::get.adjacency(igraph::barabasi.game(n, power = ps,
                                                 directed = FALSE))))
}

# Watts-Strogatz graph
WS <- function(n, pr, K=8) {
    return(as.matrix(igraph::get.adjacency(igraph::watts.strogatz.game(1, n, K, 
                                                                       pr))))
}

# K-regular game
KR <- function(n, k) {
    return(as.matrix(igraph::get.adjacency(igraph::k.regular.game(n, k))))
}



# Theoretical densities --------------------------------------------------------

######
# Semi-circle law - support is on [-2,2]
# this way of coding produces warnings but I don't care
semi.circle <- function(x){
  res <- sqrt(4-x^2)/2/pi
  res[(x > 2) | (x < -2)] <- 0
  return(res)
}
##
# semi.circle <- function(x){
#   res <- rep(NA,length(x))
#   for (i in 1:length(x))
#     res[i] <- if ((x[i] > 2) | (x[i] < -2)) {0} else sqrt(4-x[i]^2)/2/pi
#   return(res)
# }
# p-Semi-circle law - support is on [-2sqrt(p(1-p)),2sqrt(p(1-p))]
p.semi.circle <- function(x,p){
  v <- p*(1-p)
  res <- sqrt(4*v-x^2)/2/pi/v
  res[(x > 2*sqrt(v)) | (x < -2*sqrt(v))] <- 0
  return(res)
}


p.semi.circle.cdf <- function(x, p) {
    R <- 2*sqrt(p*(1-p))
    #y <- 1 + (x*sqrt(R^2 - x^2))/(pi*(R^2))
    #y <- 0.5+((asin(x/R))/pi)
    y <- 0.5 + asin(x/R)/pi + x*sqrt(1-x^2/R^2)/(pi*R)
    y[x < -R] <- 0
    y[x > R] <- 1
    return(y)
}

semi.circle.cdf <- function(x) {
    R <- 2
    #y <- 1 + (x*sqrt(R^2 - x^2))/(pi*(R^2))
    #y <- 0.5+((asin(x/R))/pi)
    y <- 0.5 + asin(x/R)/pi + x*sqrt(1-x^2/R^2)/(pi*R)
    y[x < -R] <- 0
    y[x > R] <- 1
    return(y)
}

d.fixed.sd <- function(x, d) {
    res <- (d*sqrt(4*(d-1) - x^2))/(2*pi*(d^2 - x^2))
    res[(x > 2*sqrt(d-1)) | (x < -2*sqrt(d-1))] <- 0
    return(res)
}

d.fixed.cdf <- function(x, d) {
    y <- d.fixed.sd(x, d)
    s <- c()
    for (i in 1:length(x)) {
        s[i] <- trapezoidSum(x[1:i], y[1:i])
    }
    s[1] <- 0
    return(s)
}


d.fixed.norm.sd <- function(x, d) {
    res <- sqrt(4-x^2)/(2*pi*(1+1/(d-1)-x^2/d))
    res[(x > 2) | (x < -2)] <- 0
    return(res)
}

KLsup <- function(f1, f2) {
    sup <- which(f2$y != 0)
    f1sup <- list("x"=f1$x[sup], "y"=f1$y[sup])
    f2sup <- list("x"=f2$x[sup], "y"=f2$y[sup]) 
    return(KL(f1sup, f2sup))
}

KLinv <- function(f1, f2) { 
    return(KL(f2, f1))
}